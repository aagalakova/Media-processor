<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MediaProcessor | Relation-AI</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- ЛОКАЛЬНЫЙ FFmpeg (самохостинг в /ffmpeg/) -->
  <script src="/ffmpeg/ffmpeg.min.js"></script>

  <style>
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 28px 16px; }
    .wrap { max-width: 1100px; margin: 0 auto; background: #fff; border-radius: 18px; box-shadow: 0 18px 50px rgba(0,0,0,.18); overflow: hidden; }
    header { padding: 22px 22px 14px; background: linear-gradient(135deg, #1f2937 0%, #111827 100%); color: #fff; }
    header h1 { margin: 0 0 6px; font-size: 20px; }
    header p { margin: 0; opacity: .85; font-size: 13px; line-height: 1.4; }

    .grid { display: grid; grid-template-columns: 1.1fr .9fr; gap: 16px; padding: 18px 18px 22px; }
    @media (max-width: 940px) { .grid { grid-template-columns: 1fr; } }

    .card { border: 1px solid #e5e7eb; border-radius: 14px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 14px; color: #111827; }
    .muted { color: #6b7280; font-size: 12px; }

    .drop {
      border: 2px dashed #c7cbe6;
      background: #f7f8ff;
      border-radius: 14px;
      padding: 18px;
      text-align: center;
      cursor: pointer;
      transition: .15s;
    }
    .drop:hover { transform: translateY(-1px); }
    .drop.drag { background: #eef0ff; border-color: #8892ff; }

    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; }
    label { display: block; font-size: 12px; color: #374151; margin-bottom: 6px; }
    input, select, button, textarea {
      width: 100%;
      padding: 10px 10px;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      font-size: 13px;
      outline: none;
    }
    input:focus, select:focus, textarea:focus { border-color: #8b94ff; box-shadow: 0 0 0 3px rgba(139,148,255,.18); }

    .btns { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .btns3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; }
    button { cursor: pointer; border: none; }
    .primary { background: #4f46e5; color: #fff; }
    .primary:hover { filter: brightness(1.05); }
    .ghost { background: #eef2ff; color: #3730a3; }
    .ghost:hover { filter: brightness(1.03); }
    .danger { background: #fee2e2; color: #991b1b; }
    .danger:hover { filter: brightness(1.03); }

    .files { margin-top: 10px; max-height: 220px; overflow: auto; border: 1px solid #eef2f7; border-radius: 12px; }
    .file { display: flex; align-items: center; justify-content: space-between; gap: 10px; padding: 10px 12px; border-top: 1px solid #f1f5f9; }
    .file:first-child { border-top: none; }
    .file b { font-size: 13px; }
    .pill { font-size: 11px; color: #111827; background: #f3f4f6; padding: 4px 8px; border-radius: 999px; }

    textarea { height: 220px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 11.5px; }
    .warn { background: #fff7ed; border: 1px solid #fed7aa; color: #9a3412; padding: 10px 12px; border-radius: 12px; font-size: 12px; line-height: 1.35; margin-top: 10px; }
    .ok { background: #ecfdf5; border: 1px solid #a7f3d0; color: #065f46; padding: 10px 12px; border-radius: 12px; font-size: 12px; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>MediaProcessor | Relation-AI</h1>
      <p>Картинки — через Canvas, Видео/Аудио — через FFmpeg WASM (самохостинг из /ffmpeg). Результат — ZIP.</p>
    </header>

    <div class="grid">
      <div class="card">
        <h2>1) Файлы</h2>

        <div id="drop" class="drop">
          <div style="font-size:14px; font-weight:700;">Перетащи файлы сюда</div>
          <div class="muted" style="margin-top:6px;">или нажми для выбора (картинки / видео / аудио)</div>
          <input id="fileInput" type="file" multiple style="display:none" />
        </div>

        <div id="fileList" class="files" style="display:none;"></div>

        <div class="row">
          <div>
            <label>Базовое имя (например: logo или audio_hook)</label>
            <input id="baseName" placeholder="logo" value="logo" />
          </div>
          <div>
            <label>Схема имени</label>
            <select id="nameMode">
              <option value="base_index">base_1, base_2…</option>
              <option value="base_digits">base + цифры из исходного имени</option>
              <option value="original">оставить оригинал</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Стартовый номер (для base_1…)</label>
            <input id="startIndex" type="number" min="1" value="1" />
          </div>
          <div>
            <label>Если цифр нет (для base_digits)</label>
            <select id="digitsFallback">
              <option value="index">использовать порядковый номер</option>
              <option value="skip">оставить base без номера</option>
            </select>
          </div>
        </div>

        <div class="btns3">
          <button class="ghost" id="btnLoadFFmpeg">Проверить / загрузить FFmpeg</button>
          <button class="primary" id="btnProcess">Обработать → ZIP</button>
          <button class="danger" id="btnClear">Очистить</button>
        </div>

        <div id="ffmpegStatus" style="margin-top:10px;" class="muted">FFmpeg: не проверялся</div>

        <div id="fileProtoWarn" class="warn" style="display:none;">
          Ты открыл страницу как <b>file:///</b>. В таком режиме браузер блокирует загрузку worker/wasm.<br/>
          Открывай через Vercel (https://…) или локальный сервер.
        </div>
      </div>

      <div class="card">
        <h2>2) Настройки обработки</h2>

        <div class="row">
          <div>
            <label>Видео размер (W)</label>
            <input id="vW" type="number" min="1" value="640" />
          </div>
          <div>
            <label>Видео размер (H)</label>
            <input id="vH" type="number" min="1" value="360" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Видео формат</label>
            <select id="vFmt">
              <option value="mp4">mp4</option>
              <option value="webm">webm</option>
            </select>
          </div>
          <div>
            <label>Сохранить пропорции</label>
            <select id="keepAR">
              <option value="yes">да (contain + паддинг)</option>
              <option value="no">нет (стретч в точный размер)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Аудио формат</label>
            <select id="aFmt">
              <option value="mp3">mp3</option>
              <option value="ogg">ogg</option>
            </select>
          </div>
          <div>
            <label>Аудио битрейт</label>
            <select id="aBitrate">
              <option value="128k">128k</option>
              <option value="192k">192k</option>
              <option value="256k">256k</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Картинки формат</label>
            <select id="iFmt">
              <option value="png">png</option>
              <option value="jpg">jpg</option>
              <option value="webp">webp</option>
            </select>
          </div>
          <div>
            <label>Картинки размер (W×H)</label>
            <input id="iSize" placeholder="например 1200x1200" value="1200x1200" />
          </div>
        </div>

        <div style="margin-top:10px;" class="muted">
          Важно: если FFmpeg не загрузится — видео/аудио вернутся как оригиналы и это будет видно в логе.
        </div>

        <div style="margin-top:10px;">
          <label>Лог</label>
          <textarea id="log" readonly></textarea>
        </div>
      </div>
    </div>
  </div>

<script>
  const el = (id) => document.getElementById(id);
  const logEl = el("log");

  function log(msg) {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.value += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(line);
  }

  // ---------- FILE UI ----------
  const drop = el("drop");
  const fileInput = el("fileInput");
  const fileList = el("fileList");
  let files = [];

  drop.addEventListener("click", () => fileInput.click());
  drop.addEventListener("dragover", (e) => { e.preventDefault(); drop.classList.add("drag"); });
  drop.addEventListener("dragleave", () => drop.classList.remove("drag"));
  drop.addEventListener("drop", (e) => {
    e.preventDefault();
    drop.classList.remove("drag");
    addFiles(Array.from(e.dataTransfer.files || []));
  });
  fileInput.addEventListener("change", () => addFiles(Array.from(fileInput.files || [])));

  function addFiles(newFiles) {
    if (!newFiles.length) return;
    files = files.concat(newFiles);
    renderFiles();
    log(`Добавлено файлов: ${newFiles.length} (всего: ${files.length})`);
  }

  function renderFiles() {
    if (!files.length) {
      fileList.style.display = "none";
      fileList.innerHTML = "";
      return;
    }
    fileList.style.display = "block";
    fileList.innerHTML = "";
    files.forEach((f, i) => {
      const row = document.createElement("div");
      row.className = "file";
      row.innerHTML = `
        <div style="min-width:0">
          <b title="${escapeHtml(f.name)}" style="display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(f.name)}</b>
          <div class="muted">${escapeHtml(f.type || "unknown")} · ${formatBytes(f.size)}</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <span class="pill">${detectKind(f)}</span>
          <button class="danger" style="width:auto; padding:8px 10px;" title="Удалить" onclick="removeFile(${i})">✕</button>
        </div>
      `;
      fileList.appendChild(row);
    });
  }

  window.removeFile = (idx) => {
    files.splice(idx, 1);
    renderFiles();
  };

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (m) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }
  function formatBytes(bytes) {
    const u = ["B","KB","MB","GB"];
    let i = 0, n = bytes;
    while (n >= 1024 && i < u.length-1) { n/=1024; i++; }
    return `${n.toFixed(i===0?0:1)} ${u[i]}`;
  }

  function detectKind(file) {
    const t = (file.type || "").toLowerCase();
    const n = file.name.toLowerCase();
    if (t.startsWith("image/") || /\.(png|jpg|jpeg|webp|gif|bmp)$/i.test(n)) return "image";
    if (t.startsWith("video/") || /\.(mp4|mov|mkv|webm|avi|m4v)$/i.test(n)) return "video";
    if (t.startsWith("audio/") || /\.(mp3|wav|ogg|m4a|aac|flac)$/i.test(n)) return "audio";
    return "file";
  }

  // ---------- FFmpeg ----------
  let ffmpeg = null;
  let ffmpegReady = false;

  function isHttp() {
    return location.protocol === "http:" || location.protocol === "https:";
  }

  async function checkStatic(path) {
    const url = isHttp() ? (new URL(path, location.origin)).toString() : path;
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`${path} -> HTTP ${res.status}`);
    return true;
  }

  async function initFFmpeg() {
    if (ffmpegReady) return true;

    if (location.protocol === "file:") {
      el("fileProtoWarn").style.display = "block";
      throw new Error("Нельзя запускать FFmpeg из file:/// — открой через https:// (Vercel) или локальный сервер.");
    }

    if (!window.FFmpeg || !window.FFmpeg.createFFmpeg) {
      throw new Error("FFmpeg библиотека не найдена. Проверь: /ffmpeg/ffmpeg.min.js существует и подключается.");
    }

    const corePath = (new URL("/ffmpeg/ffmpeg-core.js", location.origin)).toString();

    log("Проверяю наличие FFmpeg файлов в /ffmpeg/ ...");
    await checkStatic("/ffmpeg/ffmpeg.min.js");
    await checkStatic("/ffmpeg/ffmpeg-core.js");
    await checkStatic("/ffmpeg/ffmpeg-core.wasm");
    await checkStatic("/ffmpeg/ffmpeg-core.worker.js");
    log("OK: файлы /ffmpeg/* доступны.");

    const { createFFmpeg, fetchFile } = window.FFmpeg;
    window.__fetchFile = fetchFile;

    ffmpeg = createFFmpeg({
      log: true,
      corePath
    });

    ffmpeg.setLogger(({ type, message }) => {
      // type: "info" | "fferr" | "ffout"
      if (type === "fferr") log(`fferr: ${message}`);
    });

    ffmpeg.setProgress(({ ratio }) => {
      const pct = Math.round((ratio || 0) * 100);
      el("ffmpegStatus").textContent = `FFmpeg: работаю… ${pct}%`;
    });

    log(`Загружаю FFmpeg core: ${corePath}`);
    await ffmpeg.load();
    ffmpegReady = true;
    el("ffmpegStatus").textContent = "FFmpeg: готов ✅";
    log("FFmpeg успешно загружен ✅");
    return true;
  }

  // ---------- Naming ----------
  function extractDigits(name) {
    const m = String(name).match(/(\d+)/g);
    if (!m) return "";
    return m.join(""); // все группы цифр слитно
  }

  function buildOutName(file, idx, ext) {
    const base = (el("baseName").value || "file").trim();
    const mode = el("nameMode").value;
    const startIndex = Math.max(1, parseInt(el("startIndex").value || "1", 10));
    const order = startIndex + idx;

    if (mode === "original") {
      const pure = file.name.replace(/\.[^/.]+$/, "");
      return `${pure}.${ext}`;
    }

    if (mode === "base_digits") {
      const digits = extractDigits(file.name);
      if (digits) return `${base}${digits}.${ext}`;
      const fb = el("digitsFallback").value;
      if (fb === "index") return `${base}${order}.${ext}`;
      return `${base}.${ext}`;
    }

    // base_index
    return `${base}_${order}.${ext}`;
  }

  // ---------- Processing: Image (Canvas) ----------
  async function processImage(file) {
    const fmt = el("iFmt").value;
    const size = (el("iSize").value || "").toLowerCase().trim();
    const m = size.match(/^(\d+)\s*x\s*(\d+)$/);
    const targetW = m ? parseInt(m[1], 10) : null;
    const targetH = m ? parseInt(m[2], 10) : null;

    const img = await loadImageFromFile(file);
    const w = targetW || img.width;
    const h = targetH || img.height;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");

    // contain + центр (как у видео с паддингом)
    const scale = Math.min(w / img.width, h / img.height);
    const dw = Math.round(img.width * scale);
    const dh = Math.round(img.height * scale);
    const dx = Math.round((w - dw) / 2);
    const dy = Math.round((h - dh) / 2);
    ctx.clearRect(0, 0, w, h);
    ctx.drawImage(img, dx, dy, dw, dh);

    const mime = fmt === "jpg" ? "image/jpeg" : (fmt === "png" ? "image/png" : "image/webp");
    const blob = await new Promise((resolve) => canvas.toBlob(resolve, mime, 0.92));
    return new Uint8Array(await blob.arrayBuffer());
  }

  function loadImageFromFile(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error("Не удалось прочитать картинку")); };
      img.src = url;
    });
  }

  // ---------- Processing: Video/Audio (FFmpeg) ----------
  function guessExt(name) {
    const m = name.toLowerCase().match(/\.([a-z0-9]+)$/);
    return m ? m[1] : "bin";
  }

  async function processVideo(file, outExt) {
    const W = Math.max(1, parseInt(el("vW").value || "640", 10));
    const H = Math.max(1, parseInt(el("vH").value || "360", 10));
    const keep = el("keepAR").value === "yes";

    const inExt = guessExt(file.name);
    const inName = `in_${Date.now()}_${Math.random().toString(16).slice(2)}.${inExt}`;
    const outName = `out_${Date.now()}_${Math.random().toString(16).slice(2)}.${outExt}`;

    const inputData = await window.__fetchFile(file);
    ffmpeg.FS("writeFile", inName, inputData);

    const vf = keep
      ? `scale=${W}:${H}:force_original_aspect_ratio=decrease,pad=${W}:${H}:(ow-iw)/2:(oh-ih)/2,setsar=1`
      : `scale=${W}:${H},setsar=1`;

    // 1) пробуем "нормальные" кодеки
    let args;
    if (outExt === "mp4") {
      args = ["-i", inName, "-vf", vf, "-pix_fmt", "yuv420p", "-movflags", "+faststart",
              "-c:v", "libx264", "-preset", "veryfast", "-crf", "28",
              "-c:a", "aac", "-b:a", "128k",
              outName];
    } else {
      // webm
      args = ["-i", inName, "-vf", vf,
              "-c:v", "libvpx-vp9", "-crf", "33", "-b:v", "0",
              "-c:a", "libopus", "-b:a", "96k",
              outName];
    }

    try {
      log(`Видео: FFmpeg run (primary) → ${outExt} (${W}x${H}, keepAR=${keep ? "yes" : "no"})`);
      await ffmpeg.run(...args);
    } catch (e) {
      // 2) фолбэк на более простые кодеки (часто есть почти везде)
      log(`⚠️ primary-кодеки не сработали, пробую fallback… Причина: ${e?.message || e}`);
      try {
        if (outExt === "mp4") {
          // mpeg4 (простая кодировка) + aac
          args = ["-i", inName, "-vf", vf,
                  "-c:v", "mpeg4", "-q:v", "6",
                  "-c:a", "aac", "-b:a", "128k",
                  outName];
        } else {
          args = ["-i", inName, "-vf", vf,
                  "-c:v", "libvpx", "-b:v", "1200k",
                  "-c:a", "libvorbis", "-q:a", "4",
                  outName];
        }
        await ffmpeg.run(...args);
      } catch (e2) {
        log(`❌ fallback тоже не сработал: ${e2?.message || e2}`);
        // очистка
        safeUnlink(inName);
        safeUnlink(outName);
        throw new Error("FFmpeg не смог перекодировать видео (см. лог выше).");
      }
    }

    const out = ffmpeg.FS("readFile", outName);

    safeUnlink(inName);
    safeUnlink(outName);

    return out;
  }

  async function processAudio(file, outExt) {
    const bitrate = el("aBitrate").value || "128k";

    const inExt = guessExt(file.name);
    const inName = `in_${Date.now()}_${Math.random().toString(16).slice(2)}.${inExt}`;
    const outName = `out_${Date.now()}_${Math.random().toString(16).slice(2)}.${outExt}`;

    const inputData = await window.__fetchFile(file);
    ffmpeg.FS("writeFile", inName, inputData);

    let args;
    if (outExt === "mp3") {
      args = ["-i", inName, "-vn", "-c:a", "libmp3lame", "-b:a", bitrate, outName];
    } else {
      args = ["-i", inName, "-vn", "-c:a", "libvorbis", "-q:a", "4", outName];
    }

    try {
      log(`Аудио: FFmpeg run → ${outExt} (${bitrate})`);
      await ffmpeg.run(...args);
    } catch (e) {
      log(`⚠️ primary аудио-кодек не сработал, пробую fallback… Причина: ${e?.message || e}`);
      try {
        if (outExt === "mp3") {
          args = ["-i", inName, "-vn", "-c:a", "mp3", "-b:a", bitrate, outName];
        } else {
          args = ["-i", inName, "-vn", "-c:a", "opus", "-b:a", "96k", outName];
        }
        await ffmpeg.run(...args);
      } catch (e2) {
        log(`❌ fallback аудио тоже не сработал: ${e2?.message || e2}`);
        safeUnlink(inName);
        safeUnlink(outName);
        throw new Error("FFmpeg не смог перекодировать аудио (см. лог выше).");
      }
    }

    const out = ffmpeg.FS("readFile", outName);
    safeUnlink(inName);
    safeUnlink(outName);
    return out;
  }

  function safeUnlink(name) {
    try { ffmpeg.FS("unlink", name); } catch (_) {}
  }

  // ---------- MAIN ----------
  el("btnLoadFFmpeg").addEventListener("click", async () => {
    try {
      el("ffmpegStatus").textContent = "FFmpeg: проверяю…";
      await initFFmpeg();
    } catch (e) {
      el("ffmpegStatus").textContent = "FFmpeg: ошибка ❌";
      log(`❌ FFmpeg init error: ${e?.message || e}`);
    }
  });

  el("btnClear").addEventListener("click", () => {
    files = [];
    renderFiles();
    logEl.value = "";
    el("ffmpegStatus").textContent = "FFmpeg: не проверялся";
    log("Очищено.");
  });

  el("btnProcess").addEventListener("click", async () => {
    if (!files.length) return log("⚠️ Нет файлов для обработки.");

    const zip = new JSZip();

    // FFmpeg нужен только если есть видео/аудио
    const needFF = files.some(f => ["video","audio"].includes(detectKind(f)));
    if (needFF) {
      try {
        el("ffmpegStatus").textContent = "FFmpeg: загружаю…";
        await initFFmpeg();
      } catch (e) {
        el("ffmpegStatus").textContent = "FFmpeg: недоступен ❌";
        log(`❌ FFmpeg недоступен, видео/аудио будут без изменений. Причина: ${e?.message || e}`);
      }
    }

    const vFmt = el("vFmt").value;
    const aFmt = el("aFmt").value;
    const iFmt = el("iFmt").value;

    for (let i = 0; i < files.length; i++) {
      const f = files[i];
      const kind = detectKind(f);

      try {
        if (kind === "image") {
          const bytes = await processImage(f);
          const outName = buildOutName(f, i, iFmt);
          zip.file(outName, bytes);
          log(`✅ image → ${outName}`);
        } else if (kind === "video") {
          if (!ffmpegReady) {
            // без FFmpeg — кладем оригинал
            zip.file(buildOutName(f, i, guessExt(f.name)), f);
            log(`⚠️ video без FFmpeg → оригинал`);
          } else {
            const bytes = await processVideo(f, vFmt);
            const outName = buildOutName(f, i, vFmt);
            zip.file(outName, bytes);
            log(`✅ video → ${outName}`);
          }
        } else if (kind === "audio") {
          if (!ffmpegReady) {
            zip.file(buildOutName(f, i, guessExt(f.name)), f);
            log(`⚠️ audio без FFmpeg → оригинал`);
          } else {
            const bytes = await processAudio(f, aFmt);
            const outName = buildOutName(f, i, aFmt);
            zip.file(outName, bytes);
            log(`✅ audio → ${outName}`);
          }
        } else {
          // прочие файлы — как есть
          zip.file(buildOutName(f, i, guessExt(f.name)), f);
          log(`ℹ️ file → как есть`);
        }
      } catch (err) {
        log(`❌ Ошибка на файле "${f.name}": ${err?.message || err}`);
        // кладём оригинал, чтобы человек ничего не потерял
        zip.file(buildOutName(f, i, guessExt(f.name)), f);
        log(`↩️ Вернул оригинал в ZIP`);
      }
    }

    el("ffmpegStatus").textContent = ffmpegReady ? "FFmpeg: готов ✅" : "FFmpeg: не использовался";
    log("Собираю ZIP…");
    const blob = await zip.generateAsync({ type: "blob" });
    downloadBlob(blob, `MediaProcessor_${Date.now()}.zip`);
    log("✅ ZIP скачан.");
  });

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // подсказка если кто-то открыл file://
  if (location.protocol === "file:") {
    el("fileProtoWarn").style.display = "block";
    log("⚠️ Открыто как file:/// — FFmpeg работать не будет. Открой через https:// (Vercel) или локальный сервер.");
  }
</script>
</body>
</html>
