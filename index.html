<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MediaProcessor | Relation-AI</title>

  <!-- ZIP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <!-- FFmpeg (—Å–∞–º–æ—Ö–æ—Å—Ç–∏–Ω–≥). –§–∞–π–ª—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã –ø–æ /ffmpeg/... -->
  <script src="/ffmpeg/ffmpeg.min.js"></script>

  <style>
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); min-height: 100vh; padding: 28px 16px; }
    .app { max-width: 1050px; margin: 0 auto; background: #fff; border-radius: 18px; box-shadow: 0 20px 55px rgba(0,0,0,.18); overflow: hidden; }
    header { padding: 18px 20px; display:flex; gap:12px; align-items:center; justify-content:space-between;
      background: linear-gradient(135deg,#111827 0%,#1f2937 100%); color:#fff; }
    header .title { font-weight: 800; letter-spacing: .2px; }
    header .sub { opacity:.85; font-size: 13px; margin-top: 3px; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding: 8px 10px; border-radius: 999px; font-size: 13px; background: rgba(255,255,255,.12); }
    .dot { width:10px; height:10px; border-radius: 50%; background:#f59e0b; }
    .dot.ok { background:#10b981; }
    .dot.bad { background:#ef4444; }

    .content { padding: 18px 20px 22px; display:grid; grid-template-columns: 1.2fr .8fr; gap: 16px; }
    @media (max-width: 960px){ .content{ grid-template-columns: 1fr; } }

    .card { border: 1px solid #e5e7eb; border-radius: 16px; padding: 14px; }
    .card h3 { margin: 0 0 10px; font-size: 14px; color:#111827; }
    .muted { color:#6b7280; font-size: 13px; line-height: 1.4; }

    .drop {
      border: 2px dashed #c7d2fe; border-radius: 16px; padding: 18px; text-align:center;
      background: linear-gradient(180deg,#eef2ff 0%, #ffffff 100%);
      transition: .15s ease;
    }
    .drop.drag { border-color:#6366f1; transform: scale(1.005); }
    .drop strong { display:block; margin-bottom: 6px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; margin-top: 12px; }
    button, .btn {
      appearance:none; border: 0; cursor:pointer; border-radius: 12px; padding: 10px 12px;
      background:#111827; color:#fff; font-weight: 650; font-size: 13px;
    }
    button.secondary { background:#f3f4f6; color:#111827; border:1px solid #e5e7eb; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input, select {
      width: 100%; border:1px solid #e5e7eb; border-radius: 12px; padding: 10px 10px; font-size: 13px;
      outline: none;
    }
    label { display:block; font-size: 12px; color:#374151; margin: 10px 0 6px; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }

    .files { margin-top: 10px; max-height: 210px; overflow:auto; border-top:1px dashed #e5e7eb; padding-top:10px; }
    .file { display:flex; align-items:center; justify-content:space-between; gap:10px; padding: 8px 0; border-bottom:1px dashed #f1f5f9; }
    .file small { color:#6b7280; }
    .log { height: 250px; overflow:auto; background:#0b1020; color:#d1d5db; border-radius: 14px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; }
    .log .err { color:#fecaca; }
    .log .ok { color:#bbf7d0; }
    .log .warn { color:#fde68a; }
    .progress { margin-top: 10px; height: 10px; background:#e5e7eb; border-radius: 999px; overflow:hidden; }
    .bar { height:100%; width:0%; background:#6366f1; transition: width .15s ease; }
    .tiny { font-size: 12px; color:#6b7280; margin-top: 8px; }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <div>
        <div class="title">MediaProcessor | Relation-AI</div>
        <div class="sub">–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (Canvas) + –í–∏–¥–µ–æ/–ê—É–¥–∏–æ (FFmpeg WASM) + ZIP</div>
      </div>
      <div class="pill" title="–°—Ç–∞—Ç—É—Å FFmpeg">
        <span id="ffDot" class="dot"></span>
        <span id="ffText">FFmpeg: –ø—Ä–æ–≤–µ—Ä—è—é‚Ä¶</span>
      </div>
    </header>

    <div class="content">
      <!-- LEFT -->
      <div class="card">
        <h3>–§–∞–π–ª—ã</h3>

        <div id="drop" class="drop">
          <strong>–ü–µ—Ä–µ—Ç–∞—â–∏ —Ñ–∞–π–ª—ã —Å—é–¥–∞</strong>
          <div class="muted">–∏–ª–∏ –≤—ã–±–µ—Ä–∏ –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ (–∫–∞—Ä—Ç–∏–Ω–∫–∏ / –≤–∏–¥–µ–æ / –∞—É–¥–∏–æ).</div>
          <div class="row" style="justify-content:center">
            <label class="btn" style="background:#111827; padding:10px 12px; border-radius:12px; display:inline-block;">
              –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª—ã
              <input id="picker" type="file" multiple style="display:none" />
            </label>
            <button id="btnClear" class="secondary" type="button">–û—á–∏—Å—Ç–∏—Ç—å</button>
          </div>
          <div class="tiny">–í–∞–∂–Ω–æ: –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–π —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–∞–∫ <b>file://</b>. –†–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ Vercel/HTTP.</div>
        </div>

        <div class="files" id="fileList"></div>

        <div class="row">
          <button id="btnInit" class="secondary" type="button">–ó–∞–≥—Ä—É–∑–∏—Ç—å / –ø—Ä–æ–≤–µ—Ä–∏—Ç—å FFmpeg</button>
          <button id="btnProcess" type="button" disabled>–û–±—Ä–∞–±–æ—Ç–∞—Ç—å</button>
          <button id="btnZip" class="secondary" type="button" disabled>–°–∫–∞—á–∞—Ç—å ZIP</button>
        </div>

        <div class="progress" title="–ü—Ä–æ–≥—Ä–µ—Å—Å FFmpeg / –æ–±—Ä–∞–±–æ—Ç–∫–∏">
          <div id="bar" class="bar"></div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>

        <label>–†–µ–∂–∏–º</label>
        <select id="mode">
          <option value="auto" selected>–ê–≤—Ç–æ (–ø–æ —Ç–∏–ø—É —Ñ–∞–π–ª–∞)</option>
          <option value="image">–¢–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</option>
          <option value="video">–¢–æ–ª—å–∫–æ –≤–∏–¥–µ–æ</option>
          <option value="audio">–¢–æ–ª—å–∫–æ –∞—É–¥–∏–æ</option>
        </select>

        <div class="grid2">
          <div>
            <label>–®–∏—Ä–∏–Ω–∞</label>
            <input id="w" type="number" min="1" value="640" />
          </div>
          <div>
            <label>–í—ã—Å–æ—Ç–∞</label>
            <input id="h" type="number" min="1" value="360" />
          </div>
        </div>

        <label>
          <input id="keepAR" type="checkbox" checked />
          –°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ (–≤–∏–¥–µ–æ: —Å –ø–æ–ª—è–º–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ä–æ–≤–Ω–æ W√óH)
        </label>

        <div class="grid2">
          <div>
            <label>–§–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</label>
            <select id="imgFmt">
              <option value="png" selected>png</option>
              <option value="jpg">jpg</option>
              <option value="webp">webp</option>
            </select>
          </div>
          <div>
            <label>–§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ</label>
            <select id="vidFmt">
              <option value="mp4" selected>mp4 (H.264/AAC)</option>
              <option value="webm">webm (VP9/Opus)</option>
            </select>
          </div>
        </div>

        <div class="grid2">
          <div>
            <label>–§–æ—Ä–º–∞—Ç –∞—É–¥–∏–æ</label>
            <select id="audFmt">
              <option value="mp3" selected>mp3</option>
              <option value="ogg">ogg</option>
            </select>
          </div>
          <div>
            <label>–ë–∏—Ç—Ä–µ–π—Ç –∞—É–¥–∏–æ</label>
            <select id="audBr">
              <option value="128k">128k</option>
              <option value="192k" selected>192k</option>
              <option value="256k">256k</option>
              <option value="320k">320k</option>
            </select>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid #e5e7eb; margin:14px 0;">

        <h3 style="margin:0 0 8px;">–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ</h3>

        <label>–ë–∞–∑–æ–≤–æ–µ –∏–º—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: logo, audio_hook)</label>
        <input id="baseName" type="text" placeholder="logo" value="output" />

        <label>–°—Ö–µ–º–∞ –∏–º–µ–Ω–∏</label>
        <select id="nameMode">
          <option value="keep">–û—Å—Ç–∞–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∏–º–µ–Ω–∞</option>
          <option value="seq">base_1, base_2, base_3‚Ä¶</option>
          <option value="digits" selected>base + —Ü–∏—Ñ—Ä—ã –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ (audio_hook333)</option>
        </select>

        <div class="grid2">
          <div>
            <label>–°—Ç–∞—Ä—Ç–æ–≤—ã–π –Ω–æ–º–µ—Ä (–¥–ª—è base_1‚Ä¶)</label>
            <input id="startN" type="number" min="1" value="1" />
          </div>
          <div>
            <label>
              <input id="addSize" type="checkbox" />
              –î–æ–±–∞–≤–ª—è—Ç—å —Ä–∞–∑–º–µ—Ä –≤ –∏–º—è (‚Ä¶_640x360)
            </label>
          </div>
        </div>

        <div class="tiny">
          –ï—Å–ª–∏ FFmpeg –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî –≤–∏–¥–µ–æ/–∞—É–¥–∏–æ –Ω–µ –±—É–¥—É—Ç –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω—ã (–∏ —Ç—ã —É–≤–∏–¥–∏—à—å –ø—Ä–∏—á–∏–Ω—É –≤ –ª–æ–≥–∞—Ö).
        </div>
      </div>

      <!-- LOGS -->
      <div class="card" style="grid-column:1 / -1;">
        <h3>–õ–æ–≥–∏</h3>
        <div id="log" class="log"></div>
      </div>
    </div>
  </div>

<script>
  // ---------- UI helpers ----------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const bar = $("bar");
  const ffDot = $("ffDot");
  const ffText = $("ffText");

  function log(msg, kind="") {
    const div = document.createElement("div");
    div.textContent = msg;
    if (kind) div.className = kind;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
    console[kind === "err" ? "error" : kind === "warn" ? "warn" : "log"](msg);
  }
  function setProgress(p01) {
    const pct = Math.max(0, Math.min(1, p01 || 0)) * 100;
    bar.style.width = pct.toFixed(1) + "%";
  }
  function setFFStatus(state, text) {
    ffDot.classList.remove("ok","bad");
    if (state === "ok") ffDot.classList.add("ok");
    if (state === "bad") ffDot.classList.add("bad");
    ffText.textContent = text;
  }

  // ---------- file handling ----------
  const state = {
    files: [],
    outputs: [],
    zipBlob: null,
  };

  function humanSize(bytes) {
    const u = ["B","KB","MB","GB"];
    let i = 0, n = bytes;
    while (n >= 1024 && i < u.length-1) { n /= 1024; i++; }
    return `${n.toFixed(i ? 1 : 0)} ${u[i]}`;
  }
  function detectKind(file) {
    if (!file) return "other";
    if (file.type.startsWith("image/")) return "image";
    if (file.type.startsWith("video/")) return "video";
    if (file.type.startsWith("audio/")) return "audio";
    return "other";
  }
  function renderFiles() {
    const box = $("fileList");
    box.innerHTML = "";
    if (!state.files.length) {
      box.innerHTML = `<div class="muted">–§–∞–π–ª—ã –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã.</div>`;
      $("btnProcess").disabled = true;
      return;
    }
    for (const f of state.files) {
      const row = document.createElement("div");
      row.className = "file";
      const left = document.createElement("div");
      left.innerHTML = `<div><b>${f.name}</b></div><small>${detectKind(f)} ‚Ä¢ ${humanSize(f.size)}</small>`;
      const right = document.createElement("button");
      right.type = "button";
      right.className = "secondary";
      right.textContent = "–£–¥–∞–ª–∏—Ç—å";
      right.onclick = () => {
        state.files = state.files.filter(x => x !== f);
        renderFiles();
      };
      row.appendChild(left);
      row.appendChild(right);
      box.appendChild(row);
    }
    $("btnProcess").disabled = false;
  }

  const drop = $("drop");
  drop.addEventListener("dragover", (e)=>{ e.preventDefault(); drop.classList.add("drag"); });
  drop.addEventListener("dragleave", ()=> drop.classList.remove("drag"));
  drop.addEventListener("drop", (e)=>{
    e.preventDefault();
    drop.classList.remove("drag");
    const files = Array.from(e.dataTransfer.files || []);
    addFiles(files);
  });

  $("picker").addEventListener("change", (e)=>{
    const files = Array.from(e.target.files || []);
    addFiles(files);
    e.target.value = "";
  });

  function addFiles(files) {
    if (!files.length) return;
    state.files.push(...files);
    renderFiles();
  }

  $("btnClear").onclick = () => {
    state.files = [];
    state.outputs = [];
    state.zipBlob = null;
    setProgress(0);
    $("btnZip").disabled = true;
    logEl.innerHTML = "";
    log("üßπ –û—á–∏—â–µ–Ω–æ.");
    renderFiles();
  };

  // ---------- download helpers ----------
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  // ---------- FFmpeg init (fixed) ----------
  let ffmpeg = null;
  let ffmpegLoading = null;

  async function urlExists(url) {
    try {
      const r = await fetch(url, { method: "HEAD", cache: "no-store" });
      if (r.ok) return true;
    } catch (_) {}
    // fallback: small GET
    try {
      const r = await fetch(url, {
        method: "GET",
        cache: "no-store",
        headers: { "Range": "bytes=0-0" }
      });
      return r.ok || r.status === 206;
    } catch (_) {}
    return false;
  }

  async function initFFmpeg() {
    if (location.protocol === "file:") {
      setFFStatus("bad", "FFmpeg: file:// –Ω–µ–ª—å–∑—è");
      log("‚ùå –û—Ç–∫—Ä—ã—Ç–æ –∫–∞–∫ file:// ‚Äî –±—Ä–∞—É–∑–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç –∑–∞–≥—Ä—É–∑–∫—É core. –û—Ç–∫—Ä–æ–π —á–µ—Ä–µ–∑ Vercel/HTTP.", "err");
      return false;
    }

    if (!window.FFmpeg || !FFmpeg.createFFmpeg) {
      setFFStatus("bad", "FFmpeg: –Ω–µ –Ω–∞–π–¥–µ–Ω");
      log("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω FFmpeg.createFFmpeg. –ü—Ä–æ–≤–µ—Ä—å, —á—Ç–æ /ffmpeg/ffmpeg.min.js –¥–æ—Å—Ç—É–ø–µ–Ω –∏ –ø–æ–¥–∫–ª—é—á—ë–Ω.", "err");
      return false;
    }

    if (ffmpeg && ffmpeg.isLoaded && ffmpeg.isLoaded()) {
      setFFStatus("ok", "FFmpeg: –≥–æ—Ç–æ–≤");
      return true;
    }

    if (ffmpegLoading) return ffmpegLoading;

    ffmpegLoading = (async () => {
      setFFStatus("", "FFmpeg: –∑–∞–≥—Ä—É–∂–∞—é‚Ä¶");
      setProgress(0.05);

      const { createFFmpeg } = FFmpeg;

      const localBase = `${location.origin}/ffmpeg`;
      const localCore = `${localBase}/ffmpeg-core.js`;
      const localWasm = `${localBase}/ffmpeg-core.wasm`;
      const localWorker = `${localBase}/ffmpeg-core.worker.js`;

      // –í–∞—Ä–∏–∞–Ω—Ç—ã corePath: —Å–Ω–∞—á–∞–ª–∞ –ª–æ–∫–∞–ª—å–Ω–æ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å worker+wasm), –ø–æ—Ç–æ–º CDN (—Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è 0.11.0)
      const candidates = [];

      const hasLocalCore = await urlExists(localCore);
      const hasLocalWasm = await urlExists(localWasm);
      const hasLocalWorker = await urlExists(localWorker);

      if (hasLocalCore && hasLocalWasm && hasLocalWorker) {
        candidates.push({ name: "local", corePath: localCore });
      } else {
        log("‚ö†Ô∏è –õ–æ–∫–∞–ª—å–Ω—ã–π /ffmpeg –Ω–µ–ø–æ–ª–Ω—ã–π. –ù—É–∂–Ω–æ 4 —Ñ–∞–π–ª–∞: ffmpeg.min.js, ffmpeg-core.js, ffmpeg-core.wasm, ffmpeg-core.worker.js", "warn");
        log(`   core.js: ${hasLocalCore ? "OK" : "–Ω–µ—Ç"} | wasm: ${hasLocalWasm ? "OK" : "–Ω–µ—Ç"} | worker: ${hasLocalWorker ? "OK" : "–Ω–µ—Ç"}`, "warn");
      }

      candidates.push(
        { name: "cdn-jsdelivr", corePath: "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js" },
        { name: "cdn-unpkg",    corePath: "https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js" }
      );

      for (const c of candidates) {
        try {
          log(`(FFmpeg) –ü—Ä–æ–±—É—é core: ${c.name} ‚Üí ${c.corePath}`);
          ffmpeg = createFFmpeg({
            log: true,
            corePath: c.corePath,
            progress: ({ ratio }) => setProgress(0.1 + 0.8 * (ratio || 0))
          });
          await ffmpeg.load();
          setProgress(1);
          setFFStatus("ok", `FFmpeg: –≥–æ—Ç–æ–≤ (${c.name})`);
          log(`‚úÖ FFmpeg –∑–∞–≥—Ä—É–∂–µ–Ω: ${c.name}`, "ok");
          return true;
        } catch (e) {
          log(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å core (${c.name}): ${String(e)}`, "err");
        }
      }

      setProgress(0);
      setFFStatus("bad", "FFmpeg: –æ—à–∏–±–∫–∞");
      log("‚ùå FFmpeg core –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∏ –ª–æ–∫–∞–ª—å–Ω–æ, –Ω–∏ —Å CDN.", "err");
      return false;
    })();

    const ok = await ffmpegLoading;
    ffmpegLoading = null;
    return ok;
  }

  $("btnInit").onclick = async () => {
    log("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è FFmpeg‚Ä¶");
    await initFFmpeg();
  };

  // ---------- Image processing (Canvas) ----------
  async function processImage(file, outW, outH, fmt) {
    const bmp = await createImageBitmap(file);
    const canvas = document.createElement("canvas");
    canvas.width = outW;
    canvas.height = outH;
    const ctx = canvas.getContext("2d");

    // contain (–±–µ–∑ –∏—Å–∫–∞–∂–µ–Ω–∏–π)
    const arSrc = bmp.width / bmp.height;
    const arDst = outW / outH;
    let dw, dh, dx, dy;
    if (arSrc > arDst) {
      dw = outW;
      dh = Math.round(outW / arSrc);
      dx = 0;
      dy = Math.round((outH - dh) / 2);
    } else {
      dh = outH;
      dw = Math.round(outH * arSrc);
      dy = 0;
      dx = Math.round((outW - dw) / 2);
    }

    // —Ñ–æ–Ω –¥–ª—è jpg
    if (fmt === "jpg" || fmt === "jpeg") {
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, outW, outH);
    } else {
      ctx.clearRect(0, 0, outW, outH);
    }

    ctx.drawImage(bmp, dx, dy, dw, dh);

    const mime = fmt === "jpg" ? "image/jpeg" : fmt === "webp" ? "image/webp" : "image/png";
    const blob = await new Promise(res => canvas.toBlob(res, mime, 0.92));
    if (!blob) throw new Error("Canvas toBlob –≤–µ—Ä–Ω—É–ª null");
    return blob;
  }

  // ---------- Naming ----------
  function stripExt(name) {
    return name.replace(/\.[^/.]+$/, "");
  }
  function getDigits(name) {
    const m = name.match(/(\d+)/);
    return m ? m[1] : "";
  }
  function safeName(s) {
    return (s || "output").replace(/[\\/:*?"<>|]+/g, "_").trim() || "output";
  }

  // ---------- FFmpeg video/audio ----------
  async function processVideo(file, outW, outH, fmt, keepAR) {
    const ok = await initFFmpeg();
    if (!ok) throw new Error("FFmpeg –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");

    const { fetchFile } = FFmpeg;

    const inExt = (file.name.split(".").pop() || "mp4").toLowerCase();
    const inName = `in.${inExt}`;
    const outName = `out.${fmt}`;

    // —Ñ–∏–ª—å—Ç—Ä: –ª–∏–±–æ —Ç–æ—á–Ω—ã–π scale, –ª–∏–±–æ scale+pad (—á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ä–æ–≤–Ω–æ WxH –±–µ–∑ –∏—Å–∫–∞–∂–µ–Ω–∏–π)
    const vf = keepAR
      ? `scale=${outW}:${outH}:force_original_aspect_ratio=decrease,pad=${outW}:${outH}:(ow-iw)/2:(oh-ih)/2`
      : `scale=${outW}:${outH}`;

    ffmpeg.FS("writeFile", inName, await fetchFile(file));

    let args;
    if (fmt === "mp4") {
      args = ["-i", inName, "-vf", vf,
        "-c:v", "libx264", "-preset", "veryfast", "-crf", "23",
        "-c:a", "aac", "-b:a", "128k",
        outName
      ];
    } else {
      // webm
      args = ["-i", inName, "-vf", vf,
        "-c:v", "libvpx-vp9", "-crf", "32", "-b:v", "0",
        "-c:a", "libopus", "-b:a", "96k",
        outName
      ];
    }

    try {
      await ffmpeg.run(...args);
    } catch (e) {
      // –µ—Å–ª–∏ –∫–æ–¥–µ–∫–æ–≤ –Ω–µ—Ç ‚Äî –ø–æ–∫–∞–∂–µ–º –ø–æ–Ω—è—Ç–Ω—É—é –æ—à–∏–±–∫—É
      throw new Error("FFmpeg –Ω–µ —Å–º–æ–≥ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å (–≤–æ–∑–º–æ–∂–Ω–æ, –≤ —Å–±–æ—Ä–∫–µ –Ω–µ—Ç –Ω—É–∂–Ω—ã—Ö –∫–æ–¥–µ–∫–æ–≤). –î–µ—Ç–∞–ª–∏: " + String(e));
    }

    const data = ffmpeg.FS("readFile", outName);
    const blob = new Blob([data.buffer], { type: fmt === "mp4" ? "video/mp4" : "video/webm" });

    // cleanup
    try { ffmpeg.FS("unlink", inName); } catch (_) {}
    try { ffmpeg.FS("unlink", outName); } catch (_) {}

    return blob;
  }

  async function processAudio(file, fmt, bitrate) {
    const ok = await initFFmpeg();
    if (!ok) throw new Error("FFmpeg –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");

    const { fetchFile } = FFmpeg;
    const inExt = (file.name.split(".").pop() || "mp3").toLowerCase();
    const inName = `in.${inExt}`;
    const outName = `out.${fmt}`;

    ffmpeg.FS("writeFile", inName, await fetchFile(file));

    let args;
    if (fmt === "mp3") {
      args = ["-i", inName, "-vn", "-c:a", "libmp3lame", "-b:a", bitrate, outName];
    } else {
      args = ["-i", inName, "-vn", "-c:a", "libvorbis", "-q:a", "5", outName];
    }

    try {
      await ffmpeg.run(...args);
    } catch (e) {
      throw new Error("FFmpeg –Ω–µ —Å–º–æ–≥ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ. –î–µ—Ç–∞–ª–∏: " + String(e));
    }

    const data = ffmpeg.FS("readFile", outName);
    const mime = fmt === "mp3" ? "audio/mpeg" : "audio/ogg";
    const blob = new Blob([data.buffer], { type: mime });

    try { ffmpeg.FS("unlink", inName); } catch (_) {}
    try { ffmpeg.FS("unlink", outName); } catch (_) {}

    return blob;
  }

  // ---------- Main processing ----------
  function needsFFmpegForSelection() {
    const mode = $("mode").value;
    const kinds = state.files.map(detectKind);
    if (mode === "video" || mode === "audio") return true;
    if (mode === "auto") return kinds.some(k => k === "video" || k === "audio");
    return false;
  }

  $("btnProcess").onclick = async () => {
    if (!state.files.length) return;

    $("btnProcess").disabled = true;
    $("btnZip").disabled = true;
    state.zipBlob = null;
    state.outputs = [];
    setProgress(0.02);

    const mode = $("mode").value;
    const outW = parseInt($("w").value, 10);
    const outH = parseInt($("h").value, 10);
    const keepAR = $("keepAR").checked;
    const imgFmt = $("imgFmt").value;
    const vidFmt = $("vidFmt").value;
    const audFmt = $("audFmt").value;
    const audBr  = $("audBr").value;

    const baseName = safeName($("baseName").value);
    const nameMode = $("nameMode").value;
    const startN = Math.max(1, parseInt($("startN").value || "1", 10));
    const addSize = $("addSize").checked;

    log("‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏‚Ä¶");

    // –µ—Å–ª–∏ –±—É–¥—É—Ç –≤–∏–¥–µ–æ/–∞—É–¥–∏–æ ‚Äî –∑–∞—Ä–∞–Ω–µ–µ –∏–Ω–∏—Ü–∏–∏—Ä—É–µ–º FFmpeg
    if (needsFFmpegForSelection()) {
      log("‚è≥ –ù—É–∂–µ–Ω FFmpeg (–≤–∏–¥–µ–æ/–∞—É–¥–∏–æ) ‚Äî –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é‚Ä¶");
      const ok = await initFFmpeg();
      if (!ok) {
        log("‚ùå FFmpeg –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è ‚Äî –≤–∏–¥–µ–æ/–∞—É–¥–∏–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–ª—å–∑—è.", "err");
      }
    }

    let seq = startN;
    const zip = new JSZip();
    const sizeSuffix = `${outW}x${outH}`;

    for (let i = 0; i < state.files.length; i++) {
      const f = state.files[i];
      const kind = detectKind(f);

      // —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ä–µ–∂–∏–º—É
      if (mode !== "auto" && kind !== mode) continue;
      if (kind === "other") { log(`‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞—é (–Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø): ${f.name}`, "warn"); continue; }

      setProgress(0.05 + 0.9 * (i / Math.max(1, state.files.length)));

      try {
        let blob, ext;

        if (kind === "image") {
          ext = imgFmt === "jpg" ? "jpg" : imgFmt;
          blob = await processImage(f, outW, outH, ext);
        } else if (kind === "video") {
          ext = vidFmt;
          blob = await processVideo(f, outW, outH, ext, keepAR);
        } else if (kind === "audio") {
          ext = audFmt;
          blob = await processAudio(f, ext, audBr);
        }

        // –∏–º—è
        let outBase;
        if (nameMode === "keep") {
          outBase = safeName(stripExt(f.name));
        } else if (nameMode === "seq") {
          outBase = `${baseName}_${seq++}`;
        } else {
          // digits: base + —Ü–∏—Ñ—Ä—ã –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ (–±–µ–∑ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏—è)
          const d = getDigits(f.name);
          outBase = d ? `${baseName}${d}` : `${baseName}${seq++}`;
        }

        if (addSize && (kind === "image" || kind === "video")) outBase += `_${sizeSuffix}`;

        const outName = `${outBase}.${ext}`;

        zip.file(outName, blob);
        state.outputs.push({ name: outName, blob });

        log(`‚úÖ ${f.name} ‚Üí ${outName}`, "ok");
      } catch (e) {
        log(`‚ùå –û—à–∏–±–∫–∞ –¥–ª—è ${f.name}: ${String(e)}`, "err");
      }
    }

    setProgress(1);

    if (!state.outputs.length) {
      log("‚ö†Ô∏è –ù–µ—á–µ–≥–æ —Å–∫–∞—á–∏–≤–∞—Ç—å (–Ω–µ—Ç —É—Å–ø–µ—à–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤).", "warn");
      $("btnProcess").disabled = false;
      return;
    }

    log("üì¶ –°–æ–±–∏—Ä–∞—é ZIP‚Ä¶");
    try {
      state.zipBlob = await zip.generateAsync({ type: "blob" });
      $("btnZip").disabled = false;
      log("‚úÖ ZIP –≥–æ—Ç–æ–≤.", "ok");
    } catch (e) {
      log("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å ZIP: " + String(e), "err");
    }

    $("btnProcess").disabled = false;
  };

  $("btnZip").onclick = () => {
    if (!state.zipBlob) return;
    downloadBlob(state.zipBlob, "MediaProcessor_output.zip");
  };

  // auto-check status on load
  window.addEventListener("load", async () => {
    renderFiles();
    setFFStatus("", "FFmpeg: –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω");
    // –Ω–µ –≥—Ä—É–∑–∏–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, —á—Ç–æ–±—ã –Ω–µ —Ç—è–Ω—É—Ç—å wasm –±–µ–∑ –Ω–∞–¥–æ–±–Ω–æ—Å—Ç–∏
    log("‚ÑπÔ∏è –ù–∞–∂–º–∏ ¬´–ó–∞–≥—Ä—É–∑–∏—Ç—å / –ø—Ä–æ–≤–µ—Ä–∏—Ç—å FFmpeg¬ª, –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ ¬´–û–±—Ä–∞–±–æ—Ç–∞—Ç—å¬ª ‚Äî FFmpeg –ø–æ–¥–≥—Ä—É–∑–∏—Ç—Å—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.");
  });
</script>
</body>
</html>
